/*
 * Please do not edit this file.
 * It was generated using rpcgen.
 */

#include "prot.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <memory.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <getopt.h>
#include <unistd.h>
#include <netdb.h>

#include <protRelayUtil.h>

#include <cpsw_sock.h>
#include <socks/libSocks.h>

#define PDMAX 20

static void usage(const char *nm)
{
	fprintf(stderr,"Usage: %s [-h] [-a <ipaddr>] [-b <ipaddr>] [-u <port>] [-p <port>] [-t <timeout>]\n\n", nm);
	fprintf(stderr,"  Query RSSI-bridge MAP service (which maps remote-target UDP ports to ephemeral TCP\n");
	fprintf(stderr,"  ports which are served by the rssi_bridge; i.e., if a bridge is s to ephemeral TCP\n");
	fprintf(stderr,"       -h              : this message.\n");
	fprintf(stderr,"       -a <ipaddr>     : IP address of target system (UDP; 'behind' rssi-bridge).\n");
	fprintf(stderr,"       -b <ipaddr>     : IP address of rssi_bridge.\n");
	fprintf(stderr,"       -u <port>       : raw UDP port on target system (channel w/o RSSI).\n");
	fprintf(stderr,"       -p <port>       : UDP port on target system (channel with RSSI).\n");
	fprintf(stderr,"       -t <timeout>    : Timeout for query (in micro-seconds).\n");
}

int
main (int argc, char **argv)
{
unsigned            i;
unsigned long       timeoutUS = 1000000;

union {
	struct sockaddr    sa;
	struct sockaddr_in sin;
}					srvr;

PortMap             maps[PDMAX];
unsigned            nMaps = 0;
int                 rval = 1;
const char         *brAddr = "127.0.0.1";
const char         *ipAddr = "127.0.0.1";
int                 opt;
int                 err;
int                 rssi;
in_addr_t			ina;
char                brPortStrBuf[20];
char               *brPortStr = brPortStrBuf;
CSockSd             sock( SOCK_STREAM, getenv( "SOCKS_PROXY" ) );

	snprintf( brPortStrBuf, sizeof(brPortStrBuf), "%u", rpcRelayServerPort() );


	while ( (opt = getopt(argc, argv, "a:p:u:b:t:")) > 0 ) {
		rssi = 0;
		switch ( opt ) {
			case 'h':
			default:
				usage( argv[0] );
				return 'h' == opt ? 0 : 1;

			case 'a': ipAddr = optarg;
				break;

			case 'b': brAddr = optarg;
				break;

			case 't':
				if ( 1 != sscanf( optarg, "%lu", &timeoutUS ) ) {
					fprintf(stderr,"Scanning arg of option -%c failed\n", opt);
					return 1;
				}

			case 'p':
				rssi = 1; /* fall thru */
			case 'u':
				if ( nMaps >= PDMAX ) {
					fprintf(stderr, "Not that many -r/-u supported\n");
					return 1;
				}
				if ( 1 != sscanf( optarg, "%hi", &maps[nMaps].reqPort ) ) {
					fprintf(stderr,"Scanning arg of option -%c failed\n", opt);
					return 1;
				}
				maps[nMaps].actPort = 0;
				maps[nMaps].flags   = 0;
				if ( rssi ) {
					maps[nMaps].flags |= MAP_PORT_DESC_FLG_RSSI;
				}
				nMaps++;
			break;
		}
	}

	if ( (err = libSocksGetByName( brAddr, brPortStr, &srvr.sa )) ) {
		fprintf( stderr, "ERROR by getaddrinfo (bad -b option): %s\n", gai_strerror( err ) );
		return 1;
	}

	sock.init( &srvr.sin, 0, 0 );

	ina = inet_addr( ipAddr );

	if ( rpcMapLookup( &srvr.sin, sock.getSd(), ina, maps, nMaps, timeoutUS ) ) {
		fprintf(stderr, "rpcMapLookup FAILED\n");
		return 1;
	}

	printf("MAP Server returned:\n");
	for ( i=0; i<nMaps; i++ ) {
		printf( "%hu -> %hu (%s)\n", maps[i].reqPort, maps[i].actPort, (maps[i].flags & MAP_PORT_DESC_FLG_RSSI) ? "rssi" : "udp " );
	}

	rval = 0;

	return rval;
}
